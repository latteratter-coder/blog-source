+++
date = '2025-09-06
title = 'Linux内核启动流程'
tags = [
    "进程",
]
categories = [
    "进程",
]
+++

# 加电复位：CPU的“本能”

当按下开机键，CPU获得电力后，其行为由硬件设计预先决定：

1. **重置寄存器**：将所有内部寄存器设置为已知的初始状态。
    
2. **进入实模式**：x86架构CPU会进入**实模式（Real Mode）**，在此模式下可直接访问最初的1MB内存，无内存保护或权限分级。
    
3. **执行第一条指令**：CPU的程序计数器（CS:IP寄存器）被硬编码指向内存地址 **`0xFFFF0`**。该地址位于主板的**BIOS**（或现代计算机的**UEFI**）固件芯片中。
    

> **至此，CPU只是机械地执行硬件设计好的步骤，对“内核”一无所知。**

# 第一棒：固件（BIOS/UEFI）

CPU开始执行固件中的代码，其主要任务是：

1. **硬件自检（POST）**：检查关键硬件（内存、显卡、键盘等）是否正常工作。
    
2. **初始化硬件**：配置主板芯片组、磁盘控制器等。
    
3. **寻找引导程序**：
    
    - **BIOS**：按照预设顺序（如：U盘->硬盘）读取存储设备的**第一个扇区（512字节）**，即**主引导记录（MBR）**，并将其加载到内存地址 **`0x7C00`** 处。
        
    - **UEFI**：更先进，直接从**EFI系统分区**中查找并加载扩展性更强的引导程序文件。
        
4. **移交控制权**：CPU跳转到 `0x7C00`（或UEFI加载的引导程序地址），开始执行引导程序代码。
    

# 第二棒：引导程序（Bootloader）

MBR中的空间很小，通常只存放引导程序的**第一阶段**。其核心任务是加载功能更全的**第二阶段**引导程序（如GRUB、Windows Boot Manager）。

第二阶段引导程序的工作：

1. **提供菜单**：允许用户选择要启动的操作系统（如果有多个）。
    
2. **识别文件系统**：具备解析磁盘文件系统（如EXT4, NTFS）的能力，而不仅仅是读写原始扇区。
    
3. **加载内核映像**：根据配置，从文件系统中找到**内核文件**（如Linux的 `/boot/vmlinuz-xxx`），并将其读取到内存中合适的位置。
    
4. **准备内核运行环境**：设置启动参数（如根文件系统位置、分辨率）。
    
5. **切换CPU模式**：将CPU从**实模式**切换到现代的**保护模式（Protected Mode）** 或 **长模式（Long Mode, 64位）**，以启用虚拟内存、权限保护等关键特性。
    
6. **跳转到内核**：最后，引导程序**跳转（jump）** 到内核在内存中的入口地址，将控制权彻底交给内核。
    

> **引导程序是内核的“引路人”，完成了从“找扇区”到“找文件”的关键跨越。**

# 第三棒：内核启动与初始化

内核启动是一个复杂的过程，可分为两个主要阶段：

## 第一阶段：架构相关初始化（汇编）

这是内核最先执行的代码，直接与CPU硬件交互，通常用汇编语言编写：

- **设置初始堆栈**
    
- **清除BSS段**：将未初始化的全局变量区域清零。
    
- **解压内核**（如果需要）：许多发行版的内核映像是压缩过的（如`vmlinuz`），此阶段会进行自解压。
    
- **启用分页（Paging）**：建立初始页表，开启MMU（内存管理单元），让CPU使用**虚拟内存地址**。这是现代操作系统的基石。
    
- **设置中断描述符表（IDT）**：为处理硬件中断、异常和系统调用做好准备。
    
- **跳转到主入口点**：最终跳转到如 `start_kernel()` 这样的C语言函数，进入内核主体。
    

## 第二阶段：通用内核初始化（C语言）

`start_kernel()` 是内核初始化的“主函数”，它调用一系列初始化函数来构建整个操作系统：

- `sched_init()`: 初始化**调度器**，创建0号进程（`idle`进程）。
    
- `mm_init()`: 初始化**内存管理**系统（伙伴系统、slab分配器）。
    
- `trap_init()` / `init_IRQ()`: 完善**中断和异常处理**机制。
    
- `time_init()`: 初始化**系统时钟**，内核开始感知时间。
    
- `vfs_caches_init()`: 初始化**虚拟文件系统（VFS）**，为挂载根文件系统做准备。
    
- **挂载根文件系统**：可能先挂载内存中的`initramfs`（临时根文件系统）来加载必要驱动，再挂载真正的根文件系统。
    
- **启动第一个用户空间进程**：这是内核初始化的**最后一步**。内核线程会尝试执行用户空间的 `/sbin/init`（或其链接，如 `/lib/systemd/systemd`）。这个进程成为所有用户进程的祖先（PID 1）。
    

> **一旦 `/sbin/init` 被执行，内核的启动过程就正式结束，控制权交给了用户空间。**

# 内核启动后，它是后台运行吗？

**答案是：否。内核不是一个在“后台”运行的进程。**

这是一个关键区别。内核的运行方式与普通程序（前台或后台）有本质不同：

**内核是：**

1. **常驻内存的代码和数据**：内核始终驻留在物理内存的受保护区域（内核空间）。
    
2. **被动的执行环境和服务提供者**：内核自身不会主动持续运行。它的代码在以下三种情况下被**被动调用**：
    
    - **系统调用（Syscall）**：应用程序主动请求操作系统服务（如读写文件），通过指令（如`syscall`）陷入内核。
        
    - **硬件中断（Interrupt）**：硬件设备需要CPU关注（如网卡收到数据、时钟滴答），触发CPU执行对应的**中断处理程序**。
        
    - **异常（Exception）**：CPU执行指令时发生错误（如除零），由内核的异常处理程序处理。
        
3. **所有进程的“底层”**：每个用户进程都像是在内核这个“地基”上建立的“房子”。当需要执行特权操作时，进程就“陷入”地基（内核）中寻求帮助。
    

| 特征        | 用户进程（前台/后台）    | 内核                        |     |
| --------- | -------------- | ------------------------- | --- |
| **运行方式**  | 主动执行自己的代码流     | 被动响应（系统调用、中断、异常）          |     |
| **存在形式**  | 进程列表中的一个实体     | 常驻内存的代码和数据结构，是进程运行的**环境** |     |
| **CPU模式** | 用户态            | 内核态（当被调用时）                |     |
| **如何结束**  | 调用`exit()`或被杀掉 | **永不结束**，直到计算机关机          |     |

# 总结与类比

计算机启动过程就像一场精心设计的接力赛：

- **CPU**：是运动员，只有跑步的本能。
    
- **BIOS/UEFI**：是第一棒教练（接生婆），确保运动员健康并把他交给下一棒。
    
- **引导程序（GRUB等）**：是第二棒领跑员（家庭教师），带领运动员到正确的位置并交棒。
    
- **内核**：是第三棒运动员兼体育场建筑师（大学），它接管比赛，并首先建造整个体育场（初始化系统），然后制定规则（系统调用），裁判比赛（调度进程）。
    
- **`init` / `systemd`**：是赛后活动组织者，根据规则启动各种游戏和服务（用户进程）。
    

内核并非后台守护进程，而是**系统的基石**。它静默地存在于内存中，等待被应用程序和硬件事件调用，从而为所有程序提供安全、可靠、统一的硬件访问和管理服务。