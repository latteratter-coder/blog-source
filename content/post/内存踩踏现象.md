+++
date = '2025-09-12'
title = '函数访问到了流程中不存在的函数'
tags = [
    "内存",
]
categories = [
    "内存",
]
+++



# 内存踩踏现象分析报告 - A操作B内存但A不崩溃，B访问时崩溃

## 📋 目录
- [问题背景](#问题背景)
- [现象分析](#现象分析)
- [测试验证](#测试验证)
- [技术原理](#技术原理)
- [实际案例](#实际案例)
- [检测方法](#检测方法)
- [防护措施](#防护措施)
- [完整测试代码](#完整测试代码)

---

## 问题背景

### 🔍 **核心问题**
> 是否存在A、B两个变量，A操作了B的内存，但是A没有崩溃，而B去正常访问自己的内容时崩溃的情况？

这个问题指向了一个非常重要的内存安全概念：**内存踩踏（Memory Corruption）**的延迟效应。

### 🎯 **问题的实际意义**
这种现象在实际软件开发中经常遇到，特别是：
- **系统崩溃难以定位**：崩溃点不是真正的问题根源
- **间歇性bug**：同样的操作有时崩溃有时不崩溃
- **多线程环境**：一个线程的错误导致另一个线程崩溃

---

## 现象分析

### ✅ **答案：确实存在这种情况！**

这种现象不仅存在，而且在实际开发中相当常见。主要原因包括：

1. **内存布局的特殊性**
2. **操作系统内存保护的延迟性**
3. **内存管理机制的复杂性**
4. **编译器优化的影响**

### 📊 **典型场景分析**

| 场景类型 | A的操作 | A的结果 | B的操作 | B的结果 |
|----------|---------|---------|---------|---------|
| **堆内存踩踏** | 越界写入32字节 | ✅ 不崩溃 | realloc() | 💥 崩溃 |
| **栈帧破坏** | 栈溢出 | ✅ 不崩溃 | 函数返回 | 💥 崩溃 |
| **函数指针篡改** | 修改函数指针表 | ✅ 不崩溃 | 调用函数指针 | 💥 执行错误代码 |
| **多线程竞争** | 越界写共享内存 | ✅ 不崩溃 | 读取被踩踏区域 | 💥 崩溃 |

---

## 测试验证

### 🧪 **实验设计**

我们设计了5个测试场景来验证这种现象：

#### 1. **相邻全局数组测试**
```c
char global_A[10];
char global_B[10];

// A通过越界访问修改B的内存
// B正常访问自己的内存时可能崩溃
```

#### 2. **堆内存踩踏测试** ⭐
```c
char* heap_A = malloc(16);
char* heap_B = malloc(16);

// A越界写入32字节，破坏堆管理结构
memset(heap_A, 'X', 32);  // A不崩溃

// B进行正常内存操作
heap_B = realloc(heap_B, 32);  // B崩溃！
```

#### 3. **栈内存踩踏测试**
```c
void function_A() {
    char buffer[16];
    // 栈溢出，破坏其他栈帧
    char overflow[2048];
    memset(overflow, 'X', sizeof(overflow));  // A不崩溃
}

void function_B() {
    char local_data[16];
    // 正常访问栈数据
    printf("%s", local_data);  // 可能崩溃
}
```

#### 4. **函数指针表踩踏**
```c
FunctionPtr function_table[5];

// A修改函数指针表
function_table[2] = corrupted_function;  // A不崩溃

// B调用函数指针
function_table[2]();  // B执行了错误的函数
```

#### 5. **多线程内存踩踏**
```c
// 线程A：越界写入共享数据
for (int i = 0; i < 150; i++) {
    shared_data[i] = 0xDEADBEEF;  // 超出100的范围
}

// 线程B：正常访问数据
char* ptr = (char*)&shared_data[99] + 10;
char value = *ptr;  // 可能访问被踩踏的内存
```

### 📈 **实际测试结果**

运行我们的测试程序得到以下结果：

```
=== 测试场景2：堆内存踩踏 ===
heap_A地址: 0x55d2ef0d86b0
heap_B地址: 0x55d2ef0d86d0
距离: 32 字节

步骤1：A进行越界写入操作...
✅ A的越界写入操作完成，A没有崩溃

步骤2：B进行正常的内存操作...
realloc(): invalid old size
[程序崩溃]
```

**✅ 验证成功！** A的越界写入没有崩溃，但B的正常realloc操作崩溃了！

---

## 技术原理

### 🔬 **为什么A不崩溃？**

#### 1. **内存保护的粒度限制**
```
操作系统内存保护以页为单位（通常4KB）
┌─────────────────────────────────────────┐
│              4KB 页面                    │
│  heap_A[16]  │  heap_B[16]  │  其他数据   │
└─────────────────────────────────────────┘
     ↑              ↑
   A越界写入32字节，仍在同一页面内
   操作系统不会触发段错误
```

#### 2. **堆管理结构的位置**
```
典型的堆内存布局：
┌──────────┬──────────┬──────────┬──────────┐
│ 管理头部  │  heap_A  │ 管理头部  │  heap_B  │
│ (8字节)  │ (16字节)  │ (8字节)  │ (16字节)  │
└──────────┴──────────┴──────────┴──────────┘
                ↑              ↑
             A越界写入破坏了B的管理头部
             但A的写入操作本身不会崩溃
```

#### 3. **写入操作的特性**
- 内存写入通常只检查页面权限
- 不检查具体的对象边界
- 只要地址可写，操作就会成功

### 💥 **为什么B会崩溃？**

#### 1. **堆管理结构被破坏**
```c
// 正常的堆块头部信息
struct heap_chunk {
    size_t size;        // 块大小
    size_t prev_size;   // 前一块大小
    // 其他管理信息
};

// A的越界写入破坏了这些信息
// 当B调用realloc时，堆管理器读取到错误的信息
```

#### 2. **数据结构一致性检查**
```c
// realloc内部会进行一致性检查
if (chunk->size != expected_size) {
    abort();  // 检测到数据损坏，主动崩溃
}
```

#### 3. **延迟的内存访问**
```c
// A的破坏是"定时炸弹"
A_corrupts_memory();  // 埋下炸弹，不爆炸
// ... 其他操作 ...
B_accesses_memory();  // 触发炸弹，崩溃
```

---

## 实际案例

### 🔍 **你提到的softbus_server崩溃**

根据你提供的崩溃信息：
```
Pid:700, Uid:1024, Process name:softbus_server
Tid:1193, Name:nStackXDFinder
#00 pc 0000000000308720 Not mapped
#01 pc 000000000015272c PostAuthEvent.cfi
#02 pc 000000000001884c libnstackx_ctrl.z.so
```

**分析**：
1. **线程1193本不应该调用PostAuthEvent**
2. **但崩溃堆栈显示确实调用了**
3. **访问了未映射的内存地址0x308720**

**可能的内存踩踏场景**：
```c
// 场景1：函数指针被踩踏
typedef void (*EventHandler)(int event, void* data);
EventHandler handler = normal_handler;

// 其他线程的内存操作意外修改了handler
// handler现在指向了PostAuthEvent

// 当nStackXDFinder调用handler时
handler(event, data);  // 实际调用了PostAuthEvent
```

```c
// 场景2：回调函数表被破坏
struct callback_table {
    EventHandler handlers[10];
};

// 某个越界写入操作修改了回调表
// handlers[5] = PostAuthEvent;

// nStackXDFinder调用回调
callbacks.handlers[5](event, data);  // 意外调用PostAuthEvent
```

### 🔧 **排查建议**

1. **检查nStackXDFinder线程中的函数指针**
2. **查看共享数据结构是否被其他线程踩踏**
3. **使用AddressSanitizer检测内存踩踏**
4. **添加函数指针有效性检查**

---

## 检测方法

### 🛠️ **编译时检测**

#### 1. **AddressSanitizer**
```bash
gcc -fsanitize=address -fno-omit-frame-pointer -o program program.c
```

**优点**：
- 能检测大部分堆栈越界
- 提供详细的错误报告
- 性能开销相对较小

**局限性**：
- 可能漏检小范围越界
- 对全局变量检测不够敏感

#### 2. **Valgrind**
```bash
valgrind --tool=memcheck --leak-check=full ./program
```

#### 3. **静态分析工具**
```bash
clang-static-analyzer program.c
cppcheck --enable=all program.c
```

### 🕵️ **运行时检测**

#### 1. **内存模式检测**
```c
// 在关键位置添加魔数检查
#define MAGIC_NUMBER 0xDEADBEEF

struct protected_data {
    uint32_t magic_start;
    char actual_data[100];
    uint32_t magic_end;
};

void check_integrity(struct protected_data* data) {
    if (data->magic_start != MAGIC_NUMBER || 
        data->magic_end != MAGIC_NUMBER) {
        printf("内存被踩踏！\n");
        abort();
    }
}
```

#### 2. **函数指针有效性检查**
```c
int is_valid_function_pointer(void* ptr) {
    // 检查指针是否在合法的代码段范围内
    extern char _text_start, _text_end;
    return (ptr >= (void*)&_text_start && ptr <= (void*)&_text_end);
}

void safe_call_function(FunctionPtr func) {
    if (is_valid_function_pointer((void*)func)) {
        func();
    } else {
        printf("无效的函数指针：%p\n", (void*)func);
    }
}
```

#### 3. **内存分配跟踪**
```c
// 重写malloc/free来添加边界检查
void* debug_malloc(size_t size) {
    size_t total_size = size + 2 * sizeof(uint32_t);
    uint32_t* ptr = malloc(total_size);
    
    ptr[0] = MAGIC_NUMBER;  // 前哨兵
    ptr[(size + sizeof(uint32_t)) / sizeof(uint32_t)] = MAGIC_NUMBER;  // 后哨兵
    
    return ptr + 1;  // 返回实际数据区域
}
```

---

## 防护措施

### 🛡️ **编程实践**

#### 1. **边界检查**
```c
// 安全的字符串复制
void safe_strcpy(char* dest, const char* src, size_t dest_size) {
    if (dest_size > 0) {
        strncpy(dest, src, dest_size - 1);
        dest[dest_size - 1] = '\0';
    }
}

// 安全的数组访问
void safe_array_access(int* array, size_t size, size_t index, int value) {
    if (index < size) {
        array[index] = value;
    } else {
        printf("数组越界：索引%zu超出范围[0, %zu)\n", index, size);
    }
}
```

#### 2. **使用安全的API**
```c
// 推荐使用的安全函数
strcpy  → strncpy 或 strlcpy
sprintf → snprintf
gets    → fgets
memcpy  → 带长度检查的版本
```

#### 3. **RAII和智能指针（C++）**
```cpp
// 使用智能指针避免手动内存管理
std::unique_ptr<char[]> buffer(new char[size]);
std::vector<char> safe_array(size);  // 自动边界检查
```

### 🔒 **系统级防护**

#### 1. **栈保护**
```bash
# 编译时启用栈保护
gcc -fstack-protector-all -o program program.c
```

#### 2. **ASLR（地址空间布局随机化）**
```bash
# 检查ASLR状态
cat /proc/sys/kernel/randomize_va_space

# 启用ASLR
echo 2 > /proc/sys/kernel/randomize_va_space
```

#### 3. **DEP/NX bit（数据执行保护）**
```bash
# 编译时启用
gcc -Wl,-z,noexecstack -o program program.c
```

### 🧪 **测试策略**

#### 1. **模糊测试（Fuzzing）**
```bash
# 使用AFL进行模糊测试
afl-gcc -o program program.c
afl-fuzz -i input_dir -o output_dir ./program
```

#### 2. **压力测试**
```c
// 多线程压力测试
void stress_test() {
    for (int i = 0; i < 1000000; i++) {
        // 进行大量内存操作
        // 观察是否出现内存踩踏
    }
}
```

#### 3. **代码审查重点**
- [ ] 所有数组访问都有边界检查
- [ ] 指针运算有范围验证
- [ ] 字符串操作使用安全函数
- [ ] 动态内存分配后检查返回值
- [ ] 多线程访问共享数据有同步保护

---

## 完整测试代码

### 📁 **文件结构**
```
test/
├── memory_corruption_test.c    # 主测试程序
├── Makefile                   # 编译脚本
└── 内存踩踏分析报告.md         # 本文档
```

### 💻 **核心测试代码**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <setjmp.h>
#include <pthread.h>

// 全局变量用于段错误处理
static jmp_buf segfault_buf;
static int segfault_occurred = 0;

void segfault_handler(int sig) {
    segfault_occurred = 1;
    longjmp(segfault_buf, 1);
}

// 测试场景：堆内存踩踏
void test_heap_memory_corruption() {
    printf("=== 堆内存踩踏测试 ===\n");
    
    char* heap_A = (char*)malloc(16);
    char* heap_B = (char*)malloc(16);
    
    printf("heap_A地址: %p\n", (void*)heap_A);
    printf("heap_B地址: %p\n", (void*)heap_B);
    
    // A的恶意操作：越界写入
    signal(SIGSEGV, segfault_handler);
    if (setjmp(segfault_buf) == 0) {
        memset(heap_A, 'X', 32);  // 写入32字节，超出16字节分配
        printf("✅ A的越界写入完成，A没有崩溃\n");
    } else {
        printf("❌ A越界写入时崩溃\n");
        return;
    }
    
    // B的正常操作：重新分配内存
    if (setjmp(segfault_buf) == 0) {
        heap_B = (char*)realloc(heap_B, 32);
        printf("✅ B的内存操作成功\n");
    } else {
        printf("💥 B在进行正常内存操作时崩溃！\n");
    }
    
    // 清理
    if (setjmp(segfault_buf) == 0) {
        free(heap_A);
        free(heap_B);
        printf("内存清理成功\n");
    } else {
        printf("💥 清理内存时崩溃！\n");
    }
}

int main() {
    printf("内存踩踏测试 - A操作B内存但A不崩溃，B访问时崩溃\n");
    printf("================================================\n");
    
    test_heap_memory_corruption();
    // 其他测试场景...
    
    return 0;
}
```

### 🚀 **编译和运行**

```bash
# 编译
make run-corruption

# 或者手动编译
gcc -Wall -Wextra -g -O0 -pthread -o memory_corruption_test memory_corruption_test.c

# 运行
./memory_corruption_test

# 使用AddressSanitizer检测
gcc -fsanitize=address -pthread -o memory_corruption_test_asan memory_corruption_test.c
./memory_corruption_test_asan
```

### 📊 **预期输出**

```
内存踩踏测试 - A操作B内存但A不崩溃，B访问时崩溃
================================================

=== 测试场景1：相邻全局数组内存踩踏 ===
[结果根据内存布局而定]

=== 测试场景2：堆内存踩踏 ===
heap_A地址: 0x55f8a1b0a6b0
heap_B地址: 0x55f8a1b0a6d0
距离: 32 字节

步骤1：A进行越界写入操作...
✅ A的越界写入操作完成，A没有崩溃

步骤2：B进行正常的内存操作...
realloc(): invalid old size
[程序异常终止 - 证明了我们的假设]
```

---

## 📝 结论

### 🎯 **核心发现**

**✅ 确实存在A操作B内存但A不崩溃，B访问时崩溃的情况！**

### 🔬 **技术总结**

1. **现象普遍性**：这种内存踩踏现象在实际开发中很常见
2. **根本原因**：操作系统内存保护的粒度和内存管理的复杂性
3. **危险性**：增加了调试难度，容易误导问题定位
4. **可检测性**：需要专门的工具和方法才能有效检测

### ⚠️ **对你的softbus_server问题的启示**

1. **nStackXDFinder线程很可能是受害者，而不是肇事者**
2. **真正的问题可能在其他线程的内存操作**
3. **函数指针或回调表可能被其他代码踩踏**
4. **需要全面检查共享数据结构的完整性**

### 💡 **防护建议**

1. **启用编译器安全选项**
2. **使用内存检测工具**
3. **实施防御性编程**
4. **加强代码审查**
5. **建立内存安全测试流程**

这种内存踩踏现象是C/C++程序中最隐蔽和危险的bug类型之一，需要开发者保持高度警惕并采取多层防护措施。

---

*报告生成时间：2025年9月12日*  
*测试环境：Linux x86_64, GCC编译器*
