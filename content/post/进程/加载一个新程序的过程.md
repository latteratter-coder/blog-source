+++
date = '2025-09-06'
title = '加载一个新程序的过程'
tags = [
    "进程",
]
categories = [
    "进程",
]
+++

# 总体概览

加载并执行一个新程序的过程可以概括为以下几步：

1. **外壳（Shell）解析命令**并准备参数。
    
2. **`fork()`：创建一个新的子进程**。这个子进程几乎是父进程（如 Shell）的完美复制品。
    
3. **`execve()`：在子进程上下文中执行“程序替换”**。这是魔法发生的地方：内核停止当前子进程的运行，清空其内存空间（除了一些保留信息），然后将**指定的可执行文件**加载到该内存空间中，并为其设置全新的运行环境。
    
4. **动态链接器（如果必要）介入**，加载程序所依赖的共享库。
    
5. **程序开始执行**，从 `main()` 函数开始。
    

整个过程的核心是 `execve()` 系统调用。下图描绘了这个过程的完整流程：
```
flowchart TD
A[用户在Shell中输入命令] --> B[Shell解析命令<br>调用fork()创建子进程]
B --> C[子进程调用execve()系统调用]
C --> D["内核处理execve()请求"]
    
subgraph D[内核处理流程]
    D1[验证文件<br>权限、格式等] --> D2[释放旧地址空间<br>“拆毁旧世界”]
    D2 --> D3[加载可执行文件<br>ELF解析、映射文本/数据段等]
    D3 --> D4[设置新堆栈<br>填充参数argv、环境变量envp]
    D4 --> D5[设置寄存器<br>将eip指向入口点]
end

D --> E{"是否为动态链接程序?"}
E -- 是 --> F[载入解释器(ld-linux)<br>由解释器加载所需共享库]
E -- 否 --> G[跳转到程序入口点_start]
F --> G
    
G --> H[执行用户程序的main()函数]
H --> I[程序正常执行]
```

# 详细过程分析

## 第1步：Shell 的工作（用户空间）

当你在 Shell 中输入 `./my_program arg1 arg2` 后：

1. Shell 解析命令，将 `"my_program"`, `"arg1"`, `"arg2"` 分别存储起来。
    
2. Shell 调用 `fork()` 系统调用，创建一个几乎是自身副本的子进程。
    

## 第2步：`fork()` - 创建进程胚子（内核空间）

- `fork()` 系统调用被执行，CPU 陷入内核。
    
- 内核创建一个新的**进程描述符（`task_struct`）**，为其分配一个新的 **PID**。
    
- 内核复制父进程的几乎所有资源给子进程，包括：
    
    - **内存空间**：通过写时复制（Copy-on-Write, COW）技术，创建一个当前和父进程完全一样的地址空间映射（但实际物理内存页暂时共享）。
        
    - **打开的文件描述符表**：子进程也继承了父进程打开的文件（stdin, stdout, stderr等）。
        
    - **进程上下文**（寄存器状态等）。
        
- 现在，系统中有了两个几乎一样的进程：父进程（Shell）和子进程。它们都从 `fork()` 返回开始执行。`fork()` 对父进程返回子进程的 PID，对子进程返回 0。代码可以通过返回值判断自己是父是子。
    

## 第3步：`execve()` - 魔法核心（从用户空间到内核空间）

在子进程中，Shell 的子进程副本会调用 `execve()` 系统调用，其原型大致如下：  
`int execve(const char *filename, char *const argv[], char *const envp[]);`

- `filename`：要加载的程序路径（`"/home/user/my_program"`）。
    
- `argv`：参数数组（`{"my_program", "arg1", "arg2", NULL}`）。
    
- `envp`：环境变量数组。
    

**一旦调用 `execve()`，内核就开始执行以下繁重的工作：**

**a. 验证与准备**

- 检查文件 `filename` 是否存在、是否具有可执行权限。
    
- 读取文件的**头部（Header）**，识别其格式（例如 ELF、Mach-O、PE）。
    

**b. “拆毁旧世界” - 释放旧地址空间**

- 内核释放子进程当前拥有的几乎所有资源（内存、信号处理函数等）。由于之前用的是写时复制，所以实际复制的物理内存页很少，释放代价低。
    
- **注意**：这里会处理一些例外，比如明确设置为“执行时关闭”（`close-on-exec`）的文件描述符会被保留，这是进程间通信的重要手段。
    

**c. “建立新世界” - 加载新程序**

- **解析可执行文件**：以最常见的 ELF 格式为例，内核会解析程序头表（Program Header Table），找到需要加载的段（Segment），如：
    
    - `.text` 段（代码段）：映射到内存的只读可执行区域。
        
    - `.data` 段（已初始化数据）：映射到内存的可读写区域。
        
    - `.bss` 段（未初始化数据）：映射到初始为零的可读写区域。
        
- **映射到内存**：内核并不急于将文件内容全部读入物理内存，而是基于**内存映射（mmap）** 机制，建立虚拟地址到文件偏移的映射关系。只有当程序实际访问某块内存时，才会通过**缺页中断（Page Fault）** 将对应的文件内容加载到物理内存。这是懒加载（Lazy Loading），非常高效。
    
- **加载解释器（动态链接器）**：如果程序是**动态链接**的（绝大多数都是），ELF 文件中会指定一个“解释器”（Interpreter），通常是 `/lib64/ld-linux-x86-64.so.2`。**内核会先将这个动态链接器本身加载到进程的地址空间并映射**。
    

**d. 设置新堆栈和寄存器**

- **设置新堆栈**：内核为进程分配新的用户态堆栈，并将 `argv` 和 `envp` 中的参数和环境变量字符串压入（或放置到）堆栈的特定位置。
    
- **设置寄存器**：在进程的内核栈中准备一个新的上下文环境。最关键的是：
    
    - 将 **指令指针（EIP/RIP）** 设置为新程序的**入口点（Entry Point）**。对于静态链接的程序，入口点就是程序本身的 `_start`。对于动态链接的程序，入口点是**动态链接器的入口点**。
        
    - 将 **栈指针（ESP/RSP）** 指向新设置的用户堆栈的顶部。
        

## 第4步：返回用户空间，开始执行

当 `execve()` 系统调用在内核中完成所有准备工作后：

1. 内核将精心准备的新上下文恢复到 CPU 寄存器。
    
2. CPU 切换回用户态。
    
3. 根据设置好的指令指针（EIP/RIP），开始执行代码。
    

**现在有两种情况：**

- **情况A：程序是静态链接的**
    
    - CPU 直接从程序的 `_start` 符号开始执行。`_start` 是程序真正的起点，由它来初始化运行环境，最后调用 `main()` 函数。
        
- **情况B：程序是动态链接的（绝大多数）**
    
    - CPU 首先跳转到**动态链接器（[ld.so](https://ld.so/)）** 的入口点。
        
    - 动态链接器开始工作：
        
        1. 它检查程序依赖哪些共享库（如 `libc.so.6`）。
            
        2. 通过 `mmap()` 将这些共享库也加载到进程的地址空间。
            
        3. 执行**重定位（Relocation）** 操作，修正程序中所有对共享库函数（如 `printf`）的引用地址（将占位符替换为实际加载的地址）。
            
        4. 执行共享库的初始化代码。
            
    - 最后，动态链接器**跳转到原始程序的 `_start` 入口点**。
        

## 第5步：执行 `main()` 函数

无论是否经过动态链接，最终控制权都会交到程序本身的 `_start` 函数。这个函数是由编译器提供的，它负责：

- 设置全局变量。
    
- 初始化标准库。
    
- 将 `argv` 和 `argc` 从堆栈中取出，准备好参数。
    
- 调用用户编写的 `main(int argc, char *argv[])` 函数。
    

至此，**你的 `main` 函数终于被调用，程序开始执行你写的代码**。

# 总结

|步骤|关键动作|执行者|
|---|---|---|
|**1. Shell解析**|解析命令，获取参数|Shell (用户态)|
|**2. `fork()`**|创建子进程副本|内核|
|**3. `execve()`**|系统调用，陷入内核|子进程 -> 内核|
|**4. 内核处理**|验证文件、释放旧空间、映射新程序、设置堆栈和寄存器|内核|
|**5. 动态链接**|加载并链接共享库|动态链接器 `ld.so` (用户态)|
|**6. 程序启动**|运行 `_start`，调用 `main()`|用户程序|

所以，`main` 函数的加载和执行是内核与动态链接器（如果需要）协同工作的结果，是一个“先破后立”的过程：先通过 `execve()` 清空当前进程的环境，再为其注入一个全新的程序生命。